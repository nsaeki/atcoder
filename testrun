#!/usr/bin/env ruby
#
# Build a source and run for test files.
#
# Usage:
#   testrun source
#       Searchs test files in current directory which name with prefix same as the source.
#       If no test file exists, waiting stdin.
#   testrun source -
#       Run for stdin.
#   testrun source testfiles...
#   testrun source testdir
#       Test for testdir/in files and check result if testdir/out directory exists.

require "optparse"
require "open3"

class TestRunner
  @@langs = {}
  @@runners = {}

  class << self
    def find_for(source)
      ext = source.split(".")[-1]
      lang = @@langs[ext]
      cls = @@runners[lang]
      raise "Not supported language = #{lang}, ext = #{ext}" unless cls
      cls
    end

    def add_runner(lang, cls, *exts)
      exts.each { |e| @@langs[e] = lang }
      @@runners[lang] = cls
    end
  end

  attr_reader :opts

  def initialize(opts = {})
    @opts = opts
    @testcases = []
    if block_given?
      yield self
    end
  end

  def compile
    raise NotImplementedError.new
  end

  def must_compile
    compile unless @compiled
  end

  def get_command_line
    raise NotImplementedError.new
  end

  def add_testcase(*cases)
    @testcases.concat(cases)
  end

  def test_all
    must_compile
    @testcases.each {|c| run_testcase(c)}
  end

  private

  def run_testcase(c)
    c.print_info(opts[:v])
    r = c.run(self)

    if r.ok == nil
      out = r.output
    else
      out = (r.ok ? green("OK") : red("WA"))
    end

    elapsed_str = "(#{r.elapsed_time} sec)"
    if r.elapsed_time > 2
      elapsed_str = red(elapsed_str)
    elsif r.elapsed_time > 1
      elapsed_str = yellow(elapsed_str)
    end

    out += " " unless out.end_with?("\n")
    puts out + elapsed_str
  end

  def green(str)
    "\e[32m#{str}\e[0m"
  end

  def red(str)
    "\e[31m#{str}\e[0m"
  end

  def yellow(str)
    "\e[33m#{str}\e[0m"
  end
end

TestResult = Struct.new(:case, :output, :ok, :elapsed_time)

class TestCase
  def initialize(input_file, expected_file = nil)
    @input_file = input_file
    @expected_file = expected_file
  end

  def run(runner)
    start = Time.now
    out = run_command(runner.get_command_line)
    elapsed = Time.now - start
    ok = @expected_file ? check_output(out) : nil
    r = TestResult.new(self, out, ok, elapsed)
  end

  def check_output(out)
    open(@expected_file) do |f|
      out.split("\n").each do |line|
        expected = f.readline.split
        return false if line.split != expected
      end
    end
    true
  end

  def print_info(verbose)
    if verbose
      puts <<~EOF
             ========> Testing file #{@input_file}
             Input:
             #{File.read(@input_file)}
             Output:
           EOF
    else
      print "#{@input_file}: "
    end
  end

  private

  def run_command(cmdline)
    out = nil
    Open3.popen2(*cmdline) do |stdin, stdout, wait_thr|
      stdin.puts(File.read(@input_file))
      out = stdout.read
    end
    out
  end
end

class StdinTestCase < TestCase
  def initialize; end
  def print_info(verbose); end

  def run_command(cmdline)
    # TODO: Supports only single line input.
    out = nil
    Open3.popen2(*cmdline) do |stdin, stdout, wait_thr|
      stdin.puts(STDIN.gets)
      out = stdout.read
    end
    out
  end
end

class TestCaseGenerator
  def self.generate(src, case_files)
    self.new(src, case_files).generate
  end

  def initialize(src, case_files)
    @src, @case_files = src, case_files
  end

  def generate
    if @case_files.size == 0
      @case_files = find_by_source_name
    end

    if @case_files.size == 0 || @case_files.first == "-"
      StdinTestCase.new
    elsif Dir.exist?(@case_files.first)
      generate_from_atcoder_dir(@case_files.first)
    else
      @case_files.map { |x| TestCase.new(x) }
    end
  end

  private

  def find_by_source_name
    task_id = @src.split(".", 2).first.split("_", 2).first
    Dir.glob("#{task_id}*").sort
      .select { |x| File.file?(x) }
      .select { |x| x.end_with?(".txt") || x.end_with?(".dat") }
  end

  def generate_from_atcoder_dir(dir)
    indir = File.join(dir, "in")
    outdir = File.join(dir, "out")
    unless Dir.exist?(indir)
      STDERR.puts "Couldn't find `in' dir in the directory: #{dir}"
      exit 1
    end
    Dir.new(indir).sort.inject([]) do |s, f|
      next s if f.start_with?(".")
      i, o = [indir, outdir].map { |x| File.join(x, f) }
      s << (File.exist?(o) ? TestCase.new(i, o) : TestCase.new(i))
    end
  end
end

### Language support
class GoTestRunner < TestRunner
  add_runner :go, self, "go"

  def binname
    "./a.out"
  end

  def compile(src)
    @compiled = true
    puts "Building #{src} into #{binname}"
    ret = system("go", "build", "-o", binname, src)
    raise "Build failed" unless ret
  end

  def get_command_line
    return [binname]
  end
end

### main
options = {}
OptionParser.new do |opts|
  opts.on("-v")
end.parse!(into: options)

source = ARGV[0]
inputs = ARGV[1..]
testcases = TestCaseGenerator.generate(source, inputs)

TestRunner.find_for(source).new(options) do |r|
  r.add_testcase(*testcases)
  r.compile(source)
  r.test_all
end
